const width = [20, 25, 33.333, 50, 100];
let index = 3
let currentWidth = width[index];
let tmp = index;
const column = [1, 2, 3, 4, 5];
const colorNumber = [1, 2, 3, 4, 5];
let r, g, b;

for (let i = 0; i <= column.length - 1; i++) {
	column[i] = document.getElementById("col-" + (i + 1));
	colorNumber[i] = document.getElementById("color-code" + (i + 1));
}

//array of objects
let colorContainer = [];

const randomColor = () => {
	const random = Math.floor(Math.random() * 256);
	return random;
};

const refresh = index => {
	column[index].style.backgroundColor = `rgb( ${colorContainer[index].rgb[0]}, ${colorContainer[index].rgb[1]}, ${colorContainer[index].rgb[2]})`;
	colorNumber[index].value = column[index].style.backgroundColor;
}

(colorGenerator = () => {
	for (let i = 0; i < column.length; i++) {
		r = randomColor();
		g = randomColor();
		b = randomColor();

		if(colorContainer.length < 5 || colorContainer[i].isLocked === false){
		colorContainer[i] = new Object({
			name: "",
			rgb:[r,g,b],
			hex: `#`,
			isLocked: false
			});
		}

		if (colorContainer[i].isLocked === false) {
			refresh(i);
		}
	}
	console.log(colorContainer);
	colGen = colorGenerator;
})();

const lock = ( value , index ) => {
	const lockIcon = ['icon-lock-open-alt', 'icon-lock', 'locked'];
	let result;
	//loop threw icon classes
	for(let i=0; i< lockIcon.length; i++){
		value.classList.toggle(lockIcon[i]);
	}
	value.classList.contains("icon-lock-open-alt") ?  result = false : result = true;
	colorContainer[index].isLocked = result;
}

const addNewColumn = () => {
	if (index != 1) {
		index--;
		for (let i = 0; i < column.length; i++) {
			column[i].style.width = width[index] + `%`;
		}
		column[tmp].classList.remove(`hide`);
		currentWidth = width[index];
		tmp += 1;
	}
}

const removeColumn = () => {
	if (index != 5) {
		index++;
		for (let i = 0; i < column.length; i++) {
			column[i].style.width = width[index] + `%`;
		}
		column[tmp - 1].classList.add(`hide`);
		currentWidth = width[index];
		tmp -= 1;
	}
}

const swapColor = ( index , dir ) => {
	let temp;
	if(dir === 'next'){
		temp = colorContainer[index + 1];
		colorContainer[index + 1] = colorContainer[index];
		colorContainer[index] = temp;
		refresh(index+1);
	}else{
		temp = colorContainer[index-1];
		colorContainer[index-1] = colorContainer[index];
		colorContainer[index] = temp;
		refresh(index-1);
	}
	refresh(index);
}

addEventListener("keyup", ( event ) => {
	if (event.keyCode === 13 || event.which === 13) {
		for (let i = 0; i < column.length; i++) {
			if (colorContainer[i].isLocked === true) {
				colorNumber[i].value = column[i].style.backgroundColor;
			} else {
				column[i].style.backgroundColor = colorNumber[i].value;
			}
		}
	}
});

const saveFileWindow = document.querySelector(".overlay");

const windowController = () => {
	saveFileWindow.classList.toggle("show");
}

const fileData = ext => {
	let data = "";
	for (i=0; i<colorArr.length; i++){
		ext ? data += `--color- ${(i + 1)} : ${colorArr[i]} \n ` : ` ${data += colorArr[i]} \n`
	}
	return `File generated by Color Palette Generator: \n ${data}`;
}

const exportFile = (data, filename, type) => {
	const file = new Blob([data], { type: type });
	if (window.navigator.msSaveOrOpenBlob) // IE10+
		window.navigator.msSaveOrOpenBlob(file, filename);
	else { // Others
		const a = document.createElement("a"),
			url = URL.createObjectURL(file);
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		setTimeout(function () {
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);
		}, 0);
	}
}
