const width = [20, 25, 33.333, 50, 100];
let index = 3;
let currentWidth = width[index];
let tmp = index;
const column = [1, 2, 3, 4, 5];
const colorNumber = [1, 2, 3, 4, 5];
let r, g, b;
const colorType = document.getElementsByClassName('menu__input');

for (let i = 0; i <= column.length - 1; i++) {
	column[i] = document.getElementById("col-" + (i + 1));
	colorNumber[i] = document.getElementById("color-code" + (i + 1));
}

//array of objects
let colorContainer = [];

const refresh = index => {
	column[index].style.backgroundColor = `rgb( ${colorContainer[index].rgb[0]}, ${colorContainer[index].rgb[1]}, ${colorContainer[index].rgb[2]})`;
	colorNumber[index].value = column[index].style.backgroundColor;
}

const randomColor = () => {
	return Math.floor(Math.random() * 256);
};

(colorGenerator = () => {
	for (let i = 0; i < column.length; i++) {
		r = randomColor();
		g = randomColor();
		b = randomColor();
		if(colorContainer.length < 5 || colorContainer[i].isLocked === false){
		colorContainer[i] = new Object({
			rgb:[r,g,b],
			hex: `#`,
			isLocked: false,
			colorSystem: ''
			});
		}
		if (colorContainer[i].isLocked === false) {
			refresh(i);
		}
	}
	colGen = colorGenerator;
})();

const lock = ( value , index ) => {
	const lockIcon = ['icon-lock-open-alt', 'icon-lock', 'locked'];
	for(let i=0; i< lockIcon.length; i++){
		value.classList.toggle(lockIcon[i]);
	}
	locked = value.classList.contains("icon-lock-open-alt");
	locked ?  result = false : result = true;
	colorContainer[index].isLocked = result;
}

const addNewColumn = () => {
	if (index != 1) {
		index--;
		for (let i = 0; i < column.length; i++) {
			column[i].style.width = width[index] + `%`;
		}
		column[tmp].classList.remove(`hide`);
		currentWidth = width[index];
		tmp += 1;
	}
}

const removeColumn = () => {
	if (index != 5) {
		index++;
		for (let i = 0; i < column.length; i++) {
			column[i].style.width = width[index] + `%`;
		}
		column[tmp - 1].classList.add(`hide`);
		currentWidth = width[index];
		tmp -= 1;
	}
}

const swapColor = ( index , dir ) => {
	let temp, swap;
	//next = [index + 1], prev = [index - 1]
	temp = (dir === 'next' ? swap = (index + 1) : swap = (index - 1));
	temp = colorContainer[swap];
	colorContainer[swap] = colorContainer[index];
	colorContainer[index] = temp;

	//refresh both columns
	refresh(swap);
	refresh(index);
}


addEventListener("keyup", event => {
	event.target.value
	isRGB;
	 console.log(event.target.value);
	 e
});

addEventListener("keyup", event => {
	let regex = /\d+/g , matchAll, rgbValue;
	if (event.keyCode === 13 || event.which === 13) {
		for (let i = 0; i < column.length; i++) {
			if (colorContainer[i].isLocked !== true) {
				rgbValue = colorNumber[i].value; 
				matchAll = rgbValue.matchAll(regex); //create object 
				matchAll = Array.from(matchAll); //convert object into array
				colorContainer[i].rgb = [parseInt(matchAll[0]), parseInt(matchAll[1]), parseInt(matchAll[2])]; //updating colorContainer object				
				column[i].style.backgroundColor = colorNumber[i].value;
			}else{
				colorNumber[i].value = column[i].style.backgroundColor;
			}
		}
	}
});

const toHexConverter = (colorObj, index) => {
	const rgbInputValue = colorObj.parentElement.parentElement.parentElement.querySelector(".menu__input"); //String
	const hexx = colorObj.parentElement.querySelector(".menu__rh .hex");
	const rgb = colorObj.parentElement.querySelector(".menu__rh .rgb");
	let reg = /\d+/g;
	let matchAll, hex;

	if(colorContainer[index].hex == "#"){
		matchAll = rgbInputValue.value.matchAll(reg);
		matchAll = Array.from(matchAll);
		for(let i=0; i<matchAll.length; i++){
			matchAll[i] = parseInt(matchAll[i]);
			hex = matchAll[i].toString(16);
			hex.length == 1 ? hex = `0${hex}` : hex = hex; // 0-9
			colorContainer[index].hex += hex;
		}
	}
	
	"rgb("+colorContainer[index].hex+")" === rgbInputValue ? console.log(true) : console.log(false);
	console.log(colorContainer[index].rgb+" "+rgbInputValue.value);

	if(colorObj.innerHTML === 'HEX') {
		rgb.classList.contains('active_color-type') ? rgb.classList.remove('active_color-type') : null;
		rgbInputValue.value = colorContainer[index].hex;
		hexx.classList.add('active_color-type');
		colorContainer[index].colorSystem = 'hex';
	} else {
		hexx.classList.contains('active_color-type') ? hexx.classList.remove('active_color-type') : null;
		rgbInputValue.value = `RGB(${colorContainer[index].rgb[0]}, ${colorContainer[index].rgb[1]}, ${colorContainer[index].rgb[2]})`;
		rgb.classList.add('active_color-type');
		colorContainer[index].colorSystem = 'rgb';
	}
	
  }

 const toRgbConverter = () => {

 } 
const saveFileWindow = document.querySelector('.overlay');

const windowController = () => {
	saveFileWindow.classList.toggle("show");
}

const fileData = ext => {
	let data = "";
	for (i=0; i<colorArr.length; i++){
		ext ? data += `--color- ${(i + 1)} : ${colorArr[i]} \n ` : ` ${data += colorArr[i]} \n`
	}
	return `File generated by Color Palette Generator: \n ${data}`;
}

const exportFile = (data, filename, type) => {
	const file = new Blob([data], { type: type });
	if (window.navigator.msSaveOrOpenBlob) // IE10+
		window.navigator.msSaveOrOpenBlob(file, filename);
	else { // Others
		const a = document.createElement("a"),
			url = URL.createObjectURL(file);
		a.href = url;
		a.download = filename;
		document.body.appendChild(a);
		a.click();
		setTimeout(function () {
			document.body.removeChild(a);
			window.URL.revokeObjectURL(url);
		}, 0);
	}
}

document.querySelector('input').addEventListener("input", text => {
	console.log(text+"halo");
})